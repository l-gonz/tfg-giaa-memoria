\section{PX4 HITL simulation and validation}
\label{sec:test-4-hitl}

% Setup:    build drone, HITL configuration
% Test:     - AirSim + follow on Windows + Pixhawk
%           - QGroundControl (without program running)
%           - PX4 to computer connection
%           - RC on AirSim
% Results:  images of wiring computer-Pixhawk

The purpose of this section is to validate the transition from using a simulated version of the flight stack running on Linux (PX4's software-in-the-loop simulation) to using a physical Pixhawk board with simulated input and output to test the flight controller interaction with the developed program.
To do so, the aim is to be able to run the follow solution to send control commands through the Pixhawk board and observe the movement of the vehicle in the AirSim simulator in the same manner as in the previous section.


To activate this new hardware-in-the-loop mode, QGroundControl contains a specific quadcopter HITL airframe configuration that sets up the board with all the required parameters.
QGroundControl automatically detects the Pixhawk 4 board when connected to the computer through its Micro-USB port.
It is also required to make changes to the AirSim configuration for the simulator to work with HITL mode, namely, activating the option to accept connections through serial.
To test the complete system configuration for HITL described in section \ref{sec:devenv} and outlined in figure \ref{fig:hitl-connections}, the Pixhawk board needs an additional channel of communication to the computer dedicated to the Mavlink exchange with the dronecontrol application.
The board will therefore have both a direct cable connection to the computer and a telemetry radio on its \texttt{TELEM1} port with a wireless link to its counterparty radio connected to the computer.
Since the AirSim simulator requires a higher update rate than the dronecontrol application it will employ the faster, cabled link, through which it can automatically connect to the board when it is started.
The dronecontrol program will connect through the telemetry radio by specifying the serial port and its baudrate.
Since the flight stack is now running on a physical controller, it is possible to add an RC antenna to the \texttt{PPM RC} port of the board to be able to fly the vehicle with a remote control unit after it has been bound to the receiver \footnote{\url{https://docs.px4.io/main/en/config/radio.html}}.
By configuring one of the switches in the RC unit to change to PX4's offboard flight mode, additional checks to the safety measures of interrupting autonomous flight on flight mode changes or loss of signal from the RC controller can be carried out.
Figure \ref{fig:hitl-setup-picture} shows all the connections mentioned.

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth, keepaspectratio]{img/placeholder.png}
  \caption{Pixhawk 4 board connected to the computer running the AirSim simulator and the dronecontrol application}
  \label{fig:hitl-setup-picture}
\end{figure}
\todo[inline]{Figure \ref{fig:hitl-setup-picture}: take picture pixhawk hitl + airsim + rc receiver + telem}

After all the necessary connections are set up, the program can be started with the following command:
\mintinline{bash}{python -m dronecontrol follow --sim --serial COM[X]:57600}, 
where the exact COM port will vary depending on the particular USB port to which the telemetry radio is connected.


\subsection{PX4 HITL validation with Raspberry Pi}
\label{sec:test-5-rpi}

% Setup:    Raspberry Pi installation, RPi-Pixhawk connection
% Test:     - AirSim + follow on RPi + Pixhawk
%           - Serial connection
% Results:  wiring, performance metrics

The next step in the transition from a fully simulated environment to real flight is to connect the future onboard computer, the Raspberry Pi 4, to the Pixhawk flight controller and proceed with more realistic tests on the exact hardware that will be controlling the drone.
The main characteristics of the Raspberry Pi that have to be ensured to be able to progress further towards autonomous flight are:
\begin{enumerate}
    \item Capacity to function when power is provided from a battery
    \item Stability of serial connection to the Pixhawk board
    \item Ability to run the dronecontrol application and all its dependencies
    \item Connection to an external camera
    \item Performance of the computer vision algorithms with reduced processing power
\end{enumerate}

% installation
% xrdp
% battery tests

The complete installation process of all the required libraries and dependencies for the Raspberry Pi is explained in appendix \ref{app:install-dronecontrol-rpi}.
The most convenient method of controlling the small computer is through a remote desktop connection, where the screen contents and mouse and keyboard input are transmitted through a local network.
This way, it is possible to access the Pi's desktop from the ground station computer even during flight.
One option to achieve this is XRDP\footnote{\url{http://xrdp.org/}}, an open-source implementation of a Microsoft Remote Desktop Protocol server compatible with the Raspberry OS.

The first hardware connection to test is the power supply to the Raspberry.
As detailed in section \ref{subsec:onboard}, the selected method for powering the companion computer in the onboard configuration is through a secondary battery.
The connection will be done with a USB to USB-C cable, from the battery to the Raspberry Pi, respectively.
The intent behind testing the power supply at this point in this process is to verify that it will be suitable for its purpose before it actually needed to power the computer onboard the vehicle.
It is necessary that this power source provides enough power to both maintain the processor running at an appropriate speed and provide power to the external camera in turn, which will be attached to the Pi's board and extract power from it.

\todo[inline]{Figure \ref{fig:power-supply}: Take picture of pixhawk + rpi with own power supply}

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth, keepaspectratio]{img/placeholder.png}
  \caption{Connections between the Raspberry Pi and the Pixhawk board for running the AirSim simulator in HITL mode}
  \label{fig:power-supply}
\end{figure}



A similar connector is used to provide a channel for the Mavlink communication between the flight controller and the onboard computer.
In this case, one end of the connector is attached to the \texttt{TELEM2} port in the board and the TX/RX pins are attached to the UART pins on the Raspberry's GPIO header.
For this serial connection to work, both the flight controller and the companion computer need some additional configuration.
The Pixhawk needs to be configured through QGroundControl to enable a secondary Mavlink channel as, by default, only the \texttt{TELEM1} port used by the telemetry radio is configured.
The necessary parameters to modify and their values are collected in table \ref{tab:telem2-params}.
On the Raspberry side, the serial port is configured to be used as a terminal by default.
This can be disabled through the \texttt{raspi-config} command-line utility (Advanced config -> Serial -> Disable terminal on serial).
After that, the \texttt{/dev/serial0} address can be used to communicate to the device attached to the UART pins at the baudrate configured through QGroundControl.
The \texttt{raspi-config} tool and the connector used between the flight controller and the companion computer are show in figure \ref{fig:serial-connection}.

\begin{table}[h!]
 \begin{center}
  \begin{tabular}{l|l}
    Parameter name & Value \\ \hline
    MAV\_1\_CONFIG & TELEM2 \\
    SER\_TEL2\_BAUD & 921600 \\
  \end{tabular}
  \caption{PX4 parameters than need to be configured to enable Mavlink communication through the secondary telemetry port}
  \label{tab:telem2-params}
 \end{center}
\end{table}


\begin{figure}
  \centering
  \includegraphics[width=.45\textwidth, keepaspectratio]{img/placeholder.png}
  \includegraphics[width=.45\textwidth, keepaspectratio]{img/placeholder.png}
  \caption{a) Picture of Rpi raspi-config || b) close-up of pixhawk to pi cable connection}
  \label{fig:serial-connection}
\end{figure}
\todo[inline]{Figure \ref{fig:serial-connection}: take screenshot of raspi-config for serial and take picture of rpi pins connection}

The test camera utility will be used to validate this configuration.
At this point, the only physical connection to the ground station running AirSim and/or QGroundControl is through the development-only micro-USB port in the Pixhawk.
The results from running: \\
\begin{listing}[h!]
    \begin{minted}[breaklines, fontsize=\footnotesize, baselinestretch=1]{bash}
dronecontrol tools test-camera --hardware /dev/serial0:921600 --sim <AirSim host IP> --pose-detection
    \end{minted}
\end{listing}\\
can be seen on figure \ref{fig:rpi-airsim-test}.
On the left side, the remote connection to the Raspberry's desktop shows the output of the dronecontrol program running the pose detection algorithm on the images received from the simulator.
On the right side, the AirSim simulator shows the movements of the vehicle as it reacts to the input from the flight controller and the companion computer.

\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth, keepaspectratio]{img/placeholder.png}
  \caption{a) RPi desktop with pose output || b) AirSim on Windows}
  \label{fig:rpi-airsim-test}
\end{figure}
\todo[inline]{Figure \ref{fig:rpi-airsim-test}: take screenshot of rpi desktop and airsim screen while running test-camera in hitl}

\subsection{Performance validation}
\label{subsec:performance}

The main question left to answer before the vehicle can take to the air with this hardware and software is whether the less powerful processor in the Raspberry Pi 4b, a quad-core ARM Cortex-A72 64-bit SoC running at 1.5GHz, can handle the detection and tracking algorithms with enough performance to get similar results to those obtained with simulated hardware and achieve good reactions to real-time movement.
To do that, the average time that the program spends on each task in the running loop can be calculated and analyzed for different scenarios.
Then it will be possible to estimate the maximum speed at which the person being followed by the algorithm can move.

% Make sure there's a good loop diagram in that section pointed below, and that the enumerated parts are explained in detail
% Match numbers to added figures
From the follow loop presented in section \ref{sec:follow} it is possible to divide the processing cost into several sections that can be measured independently: image processing, offboard control, keyboard input, and released thread.

\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth, keepaspectratio]{img/placeholder.png}
  \caption{Diagram image for all simulated hardware performance}
  \label{fig:perf-sitl-sim}
\end{figure}
\todo[inline]{Figure \ref{fig:perf-sitl-sim}: draw pie chart of time each section takes for run in airsim + sitl}

Figure \ref{fig:perf-sitl-sim} shows the time used for each task on an average run of the follow solution with simulated hardware.
The time measurements have been taken by calculating the time difference between the start and the end of each statement and averaging across every run of the loop.
The main cost in time of each execution is found in the image processing task, which takes around 91.8\% of the total loop time to run.
This is where the most significant differences in performance will come from between the simulated hardware and the solution running in the Pixhawk 4 + Raspberry Pi combination.
This image analysis process can be further subdivided to get a finer degree of control over how much time each part takes.
The three subtasks that make up image processing are:
\begin{enumerate}
    \item Get frame: request a new frame from the video source.
    \item Process: send the frame to MediaPipe library for detection and/or tracking.
    \item Detect: calculate bounding box coordinates and define whether it is a valid pose.
\end{enumerate}

This further division is shown as well in figure \ref{fig:perf-sitl-sim} with each part taking 60\%, 30\%, and 10\% of the total image processing time, respectively, resulting in a performance of around 20 FPS (frames-per-second).

Similar measurements have been taken for hardware combinations with different degrees of simulation, running the follow solution with offboard mode enabled and connected to the AirSim simulator.
These are:
\begin{enumerate}
    \item All simulated hardware: PX4 on SITL mode + dronecontrol on standalone computer + images from AirSim simulator video source.
    \item Simulated hardware with real images: PX4 on SITL mode + dronecontrol on standalone computer + images from attached camera as video source.
    \item Test hardware with AC power supply: PX4 on HITL mode on Pixhawk 4 + dronecontrol on Raspberry Pi + images from AirSim simulator video source.
    \item Test hardware with battery: PX4 on HITL mode on Pixhawk 4 + dronecontrol on Raspberry Pi powered by battery + images from AirSim simulator video source.
    \item Test hardware with real images: PX4 on HITL mode on Pixhawk 4 + dronecontrol on Raspberry Pi powered by battery + images from attached camera as video source.
\end{enumerate}


\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth, keepaspectratio]{img/placeholder.png}
  \caption{Graph (area??) image for all performance measurements and FPS}
  \label{fig:perf-analysis}
\end{figure}
\todo[inline]{Figure \ref{fig:perf-analysis}: draw graph with each task in the horizontal axis and time in the vertical, one line for each combination}


Figure \ref{fig:perf-analysis} shows the measurements taken for all the hardware combinations analyzed.

\todo[inline]{Write: comment final results from graph}
%%
%% calculate max speed for each, say if enough to run in real tests (yes)
%%

%% NICE TO HAVE:
%% Keyboard control actor in unreal that can walk around at a set speed
%% and be followed
%% EVEN NICER TO HAVE:
%% Web build of unreal project running dronecontrol

% ¿¿¿???
% Calculate horizontal field of view at target distance, target can move a third of that distance in the time it takes to run a loop.
% Speed = distance / loop time
% ¿¿¿???